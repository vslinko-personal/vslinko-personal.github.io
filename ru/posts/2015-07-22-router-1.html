<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><title>Vyacheslav Slinko's website — Изоморфный роутер в функциональной парадигме</title><link rel=stylesheet href="//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.2/normalize.min.css"><link rel=stylesheet href="//fonts.googleapis.com/css?family=Playfair+Display:400,700|PT+Sans:400,400italic,700|Inconsolata:400,700&amp;subset=latin,cyrillic"><link rel=stylesheet href="/css/screen.css"></head><body class=PostPage><div class=Header><a href="/" class=Header-Name>Vyacheslav Slinko</a><ul class=Header-Menu><li class=Header-Menu-Item><a class=Header-Link href=/resume.html>Resume</a></li><li class=Header-Menu-Item><a class=Header-Link href="/posts/">Blog</a></li></ul></div><div class=Post><div class=Post-Header><h1 class=Post-Title>Изоморфный роутер в функциональной парадигме</h1><span class=Post-Date></span></div><div class=Post-Content><p>В последнее время в мире фронтенда (и не только) становится все более популярной функциональная парадигма программирования. Я считаю, что это великолепно, так как функции гораздо проще писать и тестировать, что приводит к упрощению их поддержки. А поддержка это самое противное в прикладном программировании. Я не буду углубляться в рассказ о функциональной парадигме, но буду опираться на ее принципы. Если вы хотите узнать о ней подробнее, то рекомендую вам статью <a href="http://habrahabr.ru/post/142351/">Функциональное программирование для всех</a> и слайды <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/">Functional Programming</a>.</p><p>В добавок к функциональной парадигме, в коммьюнити фронтенда развивается идея изоморфных приложений и изоморфного кода. Под изоморфным кодом понимается такой код, который можно запустить как на клиенте (в моем случае в браузере), так и на сервере (например, в node.js). Плюсы очевидны — возможность переиспользования одного и того же кода на двух платформах.</p><p>Для того, чтобы объяснить в чем суть изоморфного приложения, необходимо рассказать об основной проблеме современных клиентских приложений. Сейчас, когда мобильное устройство есть практически у каждого человека, но мобильная связь зачастую оставляет желать лучшего, приоритетами разработки являются оптимизация скорости загрузки и увеличение интерактивности приложения. Классические веб-сайты хорошо справляются со скоростью инициализации, но в них практически нет интерактивности. Веб-приложения же очень интерактивны, но на медленном соединении приходится долго ждать, пока все ресурсы загрузятся на устройство.</p><p>Эти проблемы решаются в изоморфных приложениях. Используя изоморфный код, сервер, при каждом обращении к нему, запускает у себя копию клиентского приложения, инициализирует его, и отдает клиенту уже отрендеренный первый экран. Клиент, в свою очередь, может сразу отобразить этот экран пользователю, пока в фоне продолжается загрузка всех необходимых ресурсов. После того, как все ресурсы будут загружены, клиент запустит приложение поверх первого экрана незаметно для пользователя.</p><p>В данном цикле статей я попытаюсь описать и реализовать простой изоморфный роутер используя функциональную парадигму. Мой опыт создания архитектур в функциональной парадигме не большой, так что я рассматриваю эту попытку в большей степени как эксперимент.</p><p>Роутер я выбрал потому, что это неотъемлимая часть любого современного клиентского веб приложения. У большинства популярных фреймворков есть свои стандартные решения на этот счет, но большинство из этих решений имеют очень обширную функциональнось из коробки. Я же попытаюсь реализовать одновременно простую и легко расширяемую систему.</p><p>В своих примерах я буду использовать замечательный статический анализатор типов <a href="http://flowtype.org/">Flow</a> и все возможности, доступные в <a href="https://babeljs.io/">Babel</a>.</p><hr><h2 id=-1->Часть 1 — Определения</h2><p>Прежде всего необходимо определиться в чем заключается работа роутера и из чего он состоит. На самом деле все просто — роутер преобразует некоторый <abbr>URL</abbr> в какое-то действие которое приводит к изменению текущего экрана приложения. Это действие принято называть <em>transition</em> или переходом. Переход может быть асинхронным, в случае если для нового экрана необходимы дополнительные данные с сервера. В тоже время переход не всегда может вернуть экран приложения. Например, если переданный ему <abbr>URL</abbr> не является для него валидным. Исходя из этих тезисов переход будет следующей функцией:</p><pre><code class="hljs js">type Transition = (url: Url) =&gt; Promise&lt;?Screen&gt;</code></pre><p><abbr>URL</abbr> это простая строка, но что же такое экран? Так как я не хочу быть привязанным к конкретному фреймворку или шаблонизатору, то для меня экраном может быть любой объект.</p><pre><code class="hljs js">type Url = string
type Screen = <span class=hljs-built_in>Object</span></code></pre><p>Сам роутер из себя представляет систему, на которую можно подписаться и следить за изменениями текущего экрана и которой можно сообщить, что <abbr>URL</abbr> был изменен. В данном месте отлично бы подошла концепция <em>Observable</em> и конкретная реализация <a href=https://github.com/Reactive-Extensions/RxJS>RxJS</a>, но сейчас я не хочу усложнять роутер, поэтому реализую простое <abbr>API</abbr>:</p><pre><code class="hljs js">type Listener&lt;T&gt; = (value: ?T) =&gt; <span class=hljs-keyword>void</span>
type Subscriber&lt;T&gt; = (listener: Listener&lt;T&gt;) =&gt; Unsubscriber
type Unsubscriber = () =&gt; <span class=hljs-keyword>void</span>

type Router = {
  subscribe: Subscriber&lt;Screen&gt;,
  navigateTo: (url: Url) =&gt; Promise&lt;?Screen&gt;
}</code></pre><p>Listener — функция, которая получает изменения, Subscriber — функция подписки, которая принимает listener и возвращает функцию отписки Unsubscriber. Соответственно Router имеет функцию подписки на текущий экран и функцию для оповещения об изменении <abbr>URL</abbr>.</p><p>Изоморфность накладывает ограничение на использование синглтонов. К тому же роутер должен откуда-то узнать, какие переходы существуют. Поэтому необходимо объявить конструктор для роутера.</p><pre><code class="hljs js">type RouterCreator = (transition: Transition) =&gt; Router</code></pre><p>Можно заметить, что конструктор принимает только одну функцию перехода. Но ведь в любом приложении, для которого нужен роутер, есть как минимум несколько переходов!</p><p>Я мог бы поступить как и большинство роутеров — сделать стандарт описания роута, принимать на вход массив роутов, определить алгоритм выбора нужного. Или же я мог создать множество различных абстрактных классов, например Route, RouteCollection, RouteMatchingStrategy. Все эти варианты усложняют код и уменьшают свободу в конфигурировании. Моя же цель оставить <abbr>API</abbr> простым, насколько это возможно, и функциональный подход позволяет мне этого достичь.</p><blockquote><p>Передача одной единственной функции в роутер освобождает его от необходимости реализации различных алгоритмов, для роутера это уже готовый конструктор страницы.</p></blockquote><p>Так как переход это простая функция, то на нее можно применять паттерны из функциональной парадигмы, в том числе и функции высшего порядка. С помощью функций высшего порядка можно сделать композицию из всех своих переходов в виде одной функции. Этот паттерн я разберу подробнее в следующей части.</p><p>На этом основа для роутера готова. Остальные определения будут добавляться позже, по мере написания статей.</p><hr><h2 id=-2->Часть 2. Переходы высшего порядка</h2><p>В этой части будет больше кода, чем слов. Попробуем начать с определения пары функций переходов на два разных экрана.</p><pre><code class="hljs js">type QueryParameters = {[key: string]: string}

async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>indexTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>if</span> (url !== <span class=hljs-string>'/'</span>) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-keyword>const</span> props = await api.fetchIndexData()

  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'IndexPage'</span>, props}
}

async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>itemTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>const</span> queryParameters: ?QueryParameters = matchRoutePattern(<span class=hljs-string>'/items/:id'</span>, url)

  <span class=hljs-keyword>if</span> (!queryParameters) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-keyword>const</span> {id} = queryParameters

  <span class=hljs-keyword>const</span> props = await api.fetchItemData({id})

  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'ItemPage'</span>, props}
}</code></pre><p>Довольно просто, но я не хочу каждый раз писать проверку на валидность <abbr>URL</abbr> и каждый раз получать параметры <abbr>URL</abbr>. Я уже вынес все, что только возможно, во внешние функции, но, благодаря тому, что в JavaScript функции это first-class citizens и их можно передавать через аргументы и возвращать в качестве результата, я могу пойти еще дальше. Всю эту однообразную работу я вынесу в одну отдельную функцию которая будет создавать для меня готовые функции переходов.</p><pre><code class="hljs js">type TransitionHandler = (queryParameters: QueryParameters) =&gt; Promise&lt;Screen&gt;

type TransitionCreator = (pattern: string, handler: TransitionHandler) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createTransition</span><span class=hljs-params>(pattern: string, handler: TransitionHandler)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>transition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>const</span> queryParameters: ?QueryParameters = matchRoutePattern(pattern, url)

    <span class=hljs-keyword>if</span> (queryParameters) {
      <span class=hljs-keyword>return</span> await handler(queryParameters)
    }
  }
}</code></pre><p>Теперь определение переходов стало проще.</p><pre><code class="hljs js"><span class=hljs-keyword>const</span> indexTransition: Transition = createTransition(<span class=hljs-string>'/'</span>,
  async <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>(queryParameters: QueryParameters)</span>: <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> {
      component: <span class=hljs-string>'IndexPage'</span>,
      props: await api.fetchIndexData()
    }
  }
)

<span class=hljs-keyword>const</span> itemTransition: Transition = createTransition(<span class=hljs-string>'/items/:id'</span>,
  async <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>({id: string}: QueryParameters)</span>: <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> {
      component: <span class=hljs-string>'ItemPage'</span>,
      props: await api.fetchItemData({id})
    }
  }
)</code></pre><p>Все же, как передать эти две функции в качестве одного аргумента? Для этого необходимо создать еще функцию, которая будет комбинировать несколько переходов в один общий переход, который будет вызывать их по порядку.</p><pre><code class="hljs js">type TransitionsCombinator = (...transitions: <span class=hljs-built_in>Array</span>&lt;Transition&gt;) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combineTransitions</span><span class=hljs-params>(...transitions: Array&lt;Transition&gt;)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combinedTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>const</span> screens: <span class=hljs-built_in>Array</span>&lt;?Screen&gt; =
      await* transitions.map(transition =&gt; transition(url))

    <span class=hljs-keyword>return</span> screens.find(screen =&gt; screen !== <span class=hljs-literal>undefined</span>)
  }
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition
)</code></pre><p>Подобным образом работают большинство роутеров — перебирают роуты до первого, который соответствует <abbr>URL</abbr> и используют его. Совмещение проверки на соответствие <abbr>URL</abbr> и подготовки экрана в одной функции дает гораздо больше свобод в конфигурации не усложняя при этом <abbr>API</abbr>.</p><p>Я добавлю еще один переход в конец списка для отображения экрана для 404 страницы.</p><pre><code class="hljs js">async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>notFoundTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'NotFoundPage'</span>, props: {}}
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition,
  notFoundTransition
)</code></pre><p>Аналогичным образом я могу обернуть все переходы для отлова ошибки и последующего отображения экрана с сообщением об ошибке.</p><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createErrorTransition</span><span class=hljs-params>(transition: Transition)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>errorTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>try</span> {
      <span class=hljs-keyword>return</span> await transition(url)
    } <span class=hljs-keyword>catch</span> (error) {
      <span class=hljs-keyword>return</span> {
        component: <span class=hljs-string>'ErrorPage'</span>,
        props: {error}
      }
    }
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    indexTransition,
    itemTransition,
    notFoundTransition
  )  
)</code></pre><p>Поиграем еще немного. В большинстве роутеров есть возможность добавить группе роутов некоторый префикс.</p><pre><code class="hljs js">type PrefixTransition = (prefix: Url, transition: Transition) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixTransition</span><span class=hljs-params>(prefix: Url, transition: Transition)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>const</span> prefixRe: <span class=hljs-built_in>RegExp</span> = <span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(`^${prefix}`)

  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixedTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> await transition(url.replace(prefixRe, <span class=hljs-string>''</span>))
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    prefixTransition(
      <span class=hljs-string>'/pages'</span>,
      combineTransitions(
        indexTransition,
        itemTransition
      )
    ),
    notFoundTransition
  )
)</code></pre><p>Для реализации всего этого я использовал функции высшего порядка. Имея единый интерфейс я изменяю поведение просто обрамив одну функцию другой. Это позволяет делать одновременно очень простой и очень мощный <abbr>API</abbr>.</p><p>В следующих частях я реализую поддержку History <abbr>API</abbr> и hashchange, расскажу как использовать роутер на сервере, сделаю поддержку редиректов, покажу как просто это все тестировать, и так далее.</p><hr><p class=Post-Note>Follow me on Twitter <a href=https://twitter.com/vslinko target=blank>@vslinko</a>.</p><hr><div id=disqus_thread></div></div></div><script>!function(){var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src="//vslinko-com.disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}();</script><link rel=stylesheet href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-58596861-1', 'auto');ga('send', 'pageview');</script></body></html>