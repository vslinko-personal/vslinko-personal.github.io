<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
  <title>Viacheslav Slinko's Blog</title>
  <link>https://vslinko.com/posts/</link>
  <description>Personal blog of Viacheslav Slinko. I write about IT management, software development, personal development and anything else that interests me.</description>
  <atom:link href="https://vslinko.com/posts/rss.xml" rel="self" type="application/rss+xml" />

  
  <item>
    <title>Почему платформенные команды негативно влияют на систему</title>
    <link>https://vslinko.com/posts/2021-04-04-pochemu-platformennye-komandy-negativno-vliyayut-na-sistemu.html</link>
    <guid isPermaLink="true">https://vslinko.com/posts/2021-04-04-pochemu-platformennye-komandy-negativno-vliyayut-na-sistemu.html</guid>
    <description><![CDATA[ 
<p>Одно из частых управленческих решений в ИТ — выделение отдельных «платформенных» команд. Обычно такие команды занимаются или инфраструктурой, или системой доставки кода, или общими библиотеками, или даже «ядром продукта». Иногда таких команд делают несколько, иногда одна команда занимается всеми четырьмя частями.</p>
<p>Мотивация у такого решения — скрыть сложность от продуктовых команд, которые доставляют потоковую ценность, тем самым повысив их эффективность и продуктивность.</p>
<p>Такое решение действительно положительно влияет на скорость команд, за счет скрытия части системы и ограничения их зоны ответственности, но краткосрочно. Долгосрочно у него есть негативные последствия.</p>
<h2 id="быстро--не-всегда-хорошо">Быстро — не всегда хорошо</h2>
<p>То, что продуктовые команды начинают бежать быстро не всегда есть хорошо, так как эта скорость приводит к неподконтрольному усложнению системы. Продуктовые команды меньше задумываются о том, как их решение впишется в систему, так как больша́я часть ответственности находится вне их зоны.</p>
<p>Чтобы систему держать в балансе, необходимо одновременно уделять внимание всем аспектам — продукту, архитектуре, инфраструктуре, процессам, людям, коду (и много еще чему) — и уделять внимание постоянно, чтобы скорость движения команды замедлялась хотя бы линейно, а не по экспоненте.</p>
<p>Уделять внимание всем аспектам должна та команда, которая работает над системой и понимает ее, так как только она может достаточно глубоко рассмотреть систему с разных сторон и принимать корректные решения по ее развитию.</p>
<p>Конечно, для этого команда должна быть достаточно экспертной и потребуется качать эту экспертизу. Это сложно и долго, но это дает возможность держать сложность системы в узде и не приводить к сильному замедлению и снижению гибкости. Для этого команда должна получать как можно больше обратной связи по своей системе, а не отдавать часть обратной связи другим командам.</p>
<h2 id="расслоение-разработчиков">Расслоение разработчиков</h2>
<p>Еще такое решение способствует расслоению, так как, обычно, в платформенные команды ищут людей посильнее. За счет разного профиля работ и разных целей со временем платформенные и продуктовые разработчики начинают меньше понимать друг друга и меньше обмениваться знаниями. Платформенные разработчики перестают понимать проблемы разработки, что способствует созданию оторванных от реальности решений. Продуктовые разработчики недополучают сложных развивающих задач.</p>
<p>Часто существует риск того, что платформенная команда начинает диктовать продуктовым командам различные правила что можно делать, а что нельзя. С одной стороны это стандартизирует и унифицирует, но, с другой стороны, это так же ограничивает развитие и гибкость продуктовых команд.</p>
<h2 id="и-что-делать">И что делать?</h2>
<p>Я не хочу сказать, что платформенные команды совсем не нужны. Платформенные команды создаются для того, чтобы скрывать сложность, чтобы не делать из раза в раз одно и тоже. Это полезно. Но нужно держать границы платформенной команды под контролем. Платформенная команда должна быть Thinnest Viable Platform — должна абстрагировать сложность и являться сервисом для продуктовых команд, а не быть надзорным органом.</p>
<p>Заметили слова «сервис» и «платформа» в одном предложении? В современном мире уже существуют множество Platform as a Service, которыми можно пользоваться и многие так и делают. Так что, возможно, вам не нужна собственная команда платформы.</p>
<h2 id="источники">Источники</h2>
<ul>
  <li>Много идей получено из крутого сообщества <a href="https://t.me/modernsd" target="_blank" rel="noopener">Современная разработка ПО</a>;</li>
  <li>свой опыт и наблюдения;</li>
  <li>понятие обратной связи;</li>
  <li>статья <a href="https://martinfowler.com/articles/developer-effectiveness.html" target="_blank" rel="noopener">Maximizing Developer Effectiveness</a> напомнила о важности обратной связи для разработчиков;</li>
  <li>мысли про платформенные команды из статьи <a href="https://medium.com/better-programming/your-team-structures-aint-working-let-s-apply-team-topologies-470e8d4f7fe5" target="_blank" rel="noopener">Your Team Structures Ain’t Working. Let’s Apply Team Topologies</a>.</li>
</ul>
 ]]></description>
    <pubDate>Sun, 04 Apr 2021 00:00:00 GMT</pubDate>
  </item>
  
  <item>
    <title>Психология не только про «выговориться», но и про рациональность</title>
    <link>https://vslinko.com/posts/2021-03-27-psikhologiya-ne-tolko-pro-vygovoritsya-no-i-pro-ratsionalnost.html</link>
    <guid isPermaLink="true">https://vslinko.com/posts/2021-03-27-psikhologiya-ne-tolko-pro-vygovoritsya-no-i-pro-ratsionalnost.html</guid>
    <description><![CDATA[ 
<p>Долгое время я воспринимал психологию и сеансы психологов только как способ «выговориться», проработать эмоции и успокоится. Оказывается, существует рациональная часть в психологии, которая меня заинтересовала. Обнаружил я ее натолкнувшись на РЭПТ — рационально-эмоциональную поведенческую терапию.</p>
<p>Смысл терапии в том, что сначала нужно понять и осознать иррациональные убеждения, которые сидят в голове человека, после их деконструировать и заменить другими, более рациональными.</p>
<p>Конечно, это помогает работать и с эмоциями, так как эмоции вызывает наша интерпретация ситуации, а не сами события. Человек убежденный, что при столкновении с пауком он неминуемо погибнет, будет испытывать сильные негативные эмоции, в отличие от человека без такого убеждения.</p>
<h2 id="важно-работать-с-убеждениями">Важно работать с убеждениями</h2>
<p>Наши действия определяют нас и нашу судьбу, а наши действия результат работы нашего мозга.</p>
<blockquote>
  <p>Посеешь мысль — пожнешь поступок, посеешь поступок — пожнешь привычку, посеешь привычку — пожнешь характер, посеешь характер — пожнешь судьбу.</p>
</blockquote>
<p>Иррациональные убеждения закладываются окружением или событиями, зачастую в детстве. Отсутствие иррациональных убеждений позволяет открыто смотреть на мир, замечать и использовать больше возможностей. Поэтому важно работать с ними как можно раньше.</p>
 ]]></description>
    <pubDate>Sat, 27 Mar 2021 00:00:00 GMT</pubDate>
  </item>
  
  <item>
    <title>Потребление информации ≠ обучение</title>
    <link>https://vslinko.com/posts/2021-03-20-potreblenie-informatsii-ne-ravno-obuchenie.html</link>
    <guid isPermaLink="true">https://vslinko.com/posts/2021-03-20-potreblenie-informatsii-ne-ravno-obuchenie.html</guid>
    <description><![CDATA[ 
<p>
  Долгое время я думал, что хорошо и правильно развиваюсь.
  Я решал практические задачи, читал статьи, смотрел видео, слушал подкасты.
  И это работало, пока я не перешел в менеджмент и не обнаружил себя решающим похожие проблемы раз за разом.
</p>
<p>Мой подход к обучению был поверхностным. Потребляемая информация создавала <strong>ощущение</strong> развития, но она слабо задействовала моё «медленное» мышление.</p>
<p>Это привело к тому, что у меня много практического опыта, есть представление как что работает, но недостаточно глубинного понимания, <em>почему</em> всё так работает. При этом, в менеджменте интуитивные решения зачастую не работают, а обратная связь приходит не скоро, в отличие от программирования.</p>
<h2 id="текст-лучше-чем-видео-или-аудио">Текст лучше, чем видео или аудио</h2>
<p>Сейчас я всё больше предпочитаю текстовый формат. Текст гораздо более емкий и в тексте я могу управлять своим вниманием: перечитать абзац, поразмышлять над ним, сделать заметку.</p>
<p>Всё меньше я предпочитаю подкасты и видео. Недавно смотрел видео и поймал себя на том, что <strong>по ощущениям</strong> я получил много интересных и полезных знаний, но почти не могу их повторить. Если сейчас я смотрю образовательное видео, то регулярно ставлю видео на паузу и обдумываю услышанное.</p>
 ]]></description>
    <pubDate>Sat, 20 Mar 2021 00:00:00 GMT</pubDate>
  </item>
  
  <item>
    <title>Isomorphic router in functional paradigm</title>
    <link>https://vslinko.com/posts/2015-07-27-router-1.html</link>
    <guid isPermaLink="true">https://vslinko.com/posts/2015-07-27-router-1.html</guid>
    <description><![CDATA[ 
<p>
  Recently, the functional paradigm has become more popular in the frontend
  community and elsewhere. I think it's wonderful because functions are much
  easier to write and test, this gives us more maintainable codebase, and we all
  know that maintenance is a pain. I won't describe the functional paradigm in
  depth, but I'll use its principles. If you want to read about functional
  programming then you could read the article, <a href="http://www.defmacro.org/ramblings/fp.html" target="_blank" rel="noopener">Functional Programming For The
Rest of Us</a> and watch the slides, <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/" target="_blank" rel="noopener">Functional Programming</a>.
</p>
<p>
  In addition to functional paradigm, the frontend community is developing ideas
  about isomorphic code and isomorphic applications. In short, isomorphic code
  runs on both sides, client and server. The pros are obvious — you can use the
  same code on both platforms and not repeat yourself.
</p>
<p>
  To describe the meaning of isomorphic applications I should tell you about the
  main problem of modern client-side web applications. These days everyone
  owns some type of mobile device but the cellular network isn't good enough,
  which makes developers think about performance and interactivity. Loading time
  can be optimized on classic websites but they are not interactive enough. The
  opposite is true of web applications, which are much more interactive but have a
  long initialization process.
</p>
<p>
  These problems are solved in isomorphic applications. Using isomorphic code,
  the server could initialize an instance of the client application for every
  request. This means that the server can send a pre-rendered application screen
  to the client and the client could show it to the user while other resources are
  still loading. After all resources have been loaded by the client, it could
  initialize its own instance of the application and replace the screen without
  the user knowing.
</p>
<p>
  In this article series I'll try to describe and implement a simple isomorphic
  router using functional paradigm principles. My experience as a functional API
  architect isn't extensive, so I consider this an experiment.
</p>
<p>
  I choose router because it's an important and integral part of any modern
  client-side web application. Most popular frameworks provide their own routers
  out of the box, but these routers usually aren't simple. I'll try to implement a
  simple and extendible router at the same time.
</p>
<p>
  I'll use the awesome static type checker, <a href="http://flowtype.org/" target="_blank" rel="noopener">Flow</a>, and all of the new ECMAScript
  features available in <a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>.
</p>
<hr>
<h2 id="part-1--definitions">Part 1 — Definitions</h2>
<p>
  Before implementation I should define what the router does and the individual
  router parts. It's really simple — the router transforms some URL into an action
  which changes the current screen of application. This action is usually called a
  <em>transition</em>. A transition could be asynchronous if the new screen depends on
  some data on a server. At the same time, a transition can't return a new screen
  if the URL isn't valid for it.
</p>
<pre><code class="hljs language-js">type Transition = <span class="hljs-function">(<span class="hljs-params">url: Url</span>) =></span> <span class="hljs-built_in">Promise</span>&#x3C;?Screen></code></pre>
<p>
  The URL is just a string, but what is a screen? I don't want to depend on any
  framework or template engine so in my case, a screen could be any object.
</p>
<pre><code class="hljs language-js">type Url = string
type Screen = <span class="hljs-built_in">Object</span></code></pre>
<p>
  The router itself is a system that can push notifications about screen changes
  and can be notified about URL changes. It's very similar to <em>Observable</em>
  behavior that is implemented in the <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="noopener">RxJS</a> library, but I don't want complicate
  my router, so I just define a simple subscribe API.
</p>
<pre><code class="hljs language-js">type Listener&#x3C;T> = <span class="hljs-function">(<span class="hljs-params">value: ?T</span>) =></span> <span class="hljs-keyword">void</span>
type Subscriber&#x3C;T> = <span class="hljs-function">(<span class="hljs-params">listener: Listener&#x3C;T></span>) =></span> Unsubscriber
type Unsubscriber = <span class="hljs-function">() =></span> <span class="hljs-keyword">void</span>

type Router = {
  <span class="hljs-attr">subscribe</span>: Subscriber&#x3C;Screen>,
  navigateTo: <span class="hljs-function">(<span class="hljs-params">url: Url</span>) =></span> <span class="hljs-built_in">Promise</span>&#x3C;?Screen>
}</code></pre>
<p>
  Listener is a function that receives changes, Subscriber is a function that
  receives a listener and returns the Unsubscriber function. So Router has a
  function that subscribes on the current screen and a function that notifies the
  router about the current URL.
</p>
<p>
  Isomorphism imposes a limitation on singletones usage. Also the router should
  have knowledge about all application transitions. The router constructor solves
  that problems.
</p>
<pre><code class="hljs language-js">type RouterCreator = <span class="hljs-function">(<span class="hljs-params">transition: Transition</span>) =></span> Router</code></pre>
<p>
  You could see that this constructor receives only one transition function. But
  every single application that needs the router has at least two transitions!
</p>
<p>
  I could do it like in most big routers — write a standard for route definitions,
  accept array of routes, implement a matching algorithm, or I could provide to a
  user a lot of abstract classes like Route, RouteCollection,
  RouteMatchingStrategy, etc. All these variants make code and API more
  complicated and gives less freedom to configuration. My goal is the opposite —
  I want to make it all as simple as possible and functional paradigm helps me do
  that.
</p>
<blockquote>
  <p>
    Providing a single function into the router releases it from the requirement
    to implement different algorithms. For the router, that function is a fully
    prepared constructor of a screen.
  </p>
</blockquote>
<p>
  Transition is a simple function that's why we can apply to it every functional
  pattern, including higher-order functions. Using higher-order function, I can
  compose all application transitions into a single function. I'll describe this
  pattern in the next part.
</p>
<p>That's all for basic router parts. Other definitions will be added later.</p>
<hr>
<h2 id="part-2-higher-order-transitions">Part 2. Higher-order transitions</h2>
<p>
  This part will contain more code than words. I'll start with two transition
  functions for two screens.
</p>
<pre><code class="hljs language-js">type QueryParameters = {[key: string]: string}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
  <span class="hljs-keyword">if</span> (url !== <span class="hljs-string">'/'</span>) {
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">const</span> props = <span class="hljs-keyword">await</span> api.fetchIndexData()

  <span class="hljs-keyword">return</span> {<span class="hljs-attr">component</span>: <span class="hljs-string">'IndexPage'</span>, props}
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">itemTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
  <span class="hljs-keyword">const</span> queryParameters: ?QueryParameters = matchRoutePattern(<span class="hljs-string">'/items/:id'</span>, url)

  <span class="hljs-keyword">if</span> (!queryParameters) {
    <span class="hljs-keyword">return</span>
  }

  <span class="hljs-keyword">const</span> {id} = queryParameters

  <span class="hljs-keyword">const</span> props = <span class="hljs-keyword">await</span> api.fetchItemData({id})

  <span class="hljs-keyword">return</span> {<span class="hljs-attr">component</span>: <span class="hljs-string">'ItemPage'</span>, props}
}</code></pre>
<p>
  Pretty easy but I don't want to implement the URL matching in every transition.
  I've already extracted everything that I could into separate functions, but I can
  dig deeper. Functions in JavaScript are first-class citizens. This means that I
  can pass any function as an argument and return one function from another. Using
  these properties of JavaScript, I can write another function that will create
  transitions for me.
</p>
<pre><code class="hljs language-js">type TransitionHandler = <span class="hljs-function">(<span class="hljs-params">queryParameters: QueryParameters</span>) =></span> <span class="hljs-built_in">Promise</span>&#x3C;Screen>

type TransitionCreator = <span class="hljs-function">(<span class="hljs-params">pattern: string, handler: TransitionHandler</span>) =></span> Transition

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTransition</span>(<span class="hljs-params">pattern: string, handler: TransitionHandler</span>): <span class="hljs-title">Transition</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">const</span> queryParameters: ?QueryParameters = matchRoutePattern(pattern, url)

    <span class="hljs-keyword">if</span> (queryParameters) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> handler(queryParameters)
    }
  }
}</code></pre>
<p>Now the transitions have become simpler.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> indexTransition: Transition = createTransition(<span class="hljs-string">'/'</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">queryParameters: QueryParameters</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">component</span>: <span class="hljs-string">'IndexPage'</span>,
      <span class="hljs-attr">props</span>: <span class="hljs-keyword">await</span> api.fetchIndexData()
    }
  }
)

<span class="hljs-keyword">const</span> itemTransition: Transition = createTransition(<span class="hljs-string">'/items/:id'</span>,
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{id: string}: QueryParameters</span>): <span class="hljs-title">Promise</span>&#x3C;<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">component</span>: <span class="hljs-string">'ItemPage'</span>,
      <span class="hljs-attr">props</span>: <span class="hljs-keyword">await</span> api.fetchItemData({id})
    }
  }
)</code></pre>
<p>
  However, how can I pass these two functions into one argument? To do this I'll
  create one more function that will combine several transitions into a single
  transition that will in turn invoke them in series.
</p>
<pre><code class="hljs language-js">type TransitionsCombinator = <span class="hljs-function">(<span class="hljs-params">...transitions: <span class="hljs-built_in">Array</span>&#x3C;Transition></span>) =></span> Transition

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineTransitions</span>(<span class="hljs-params">...transitions: <span class="hljs-built_in">Array</span>&#x3C;Transition></span>): <span class="hljs-title">Transition</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combinedTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">const</span> screens: <span class="hljs-built_in">Array</span>&#x3C;?Screen> =
      <span class="hljs-keyword">await</span>* transitions.map(<span class="hljs-function"><span class="hljs-params">transition</span> =></span> transition(url))

    <span class="hljs-keyword">return</span> screens.find(<span class="hljs-function"><span class="hljs-params">screen</span> =></span> screen !== <span class="hljs-literal">undefined</span>)
  }
}

<span class="hljs-keyword">const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition
)</code></pre>
<p>
  That's how most routers works. Implementing URL matching and data fetching in
  one function gives much more freedom to configuration and does't complicate the
  API.
</p>
<p>I'll add one more transition for the screen of the 404 page.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notFoundTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
  <span class="hljs-keyword">return</span> {<span class="hljs-attr">component</span>: <span class="hljs-string">'NotFoundPage'</span>, <span class="hljs-attr">props</span>: {}}
}

<span class="hljs-keyword">const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition,
  notFoundTransition
)</code></pre>
<p>
  In the same way I can wrap all transitions so as to catch an error that I can
  use in the screen of the error page.
</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createErrorTransition</span>(<span class="hljs-params">transition: Transition</span>): <span class="hljs-title">Transition</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> transition(url)
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">component</span>: <span class="hljs-string">'ErrorPage'</span>,
        <span class="hljs-attr">props</span>: {error}
      }
    }
  }
}

<span class="hljs-keyword">const</span> allTransitions = createErrorTransition(
  combineTransitions(
    indexTransition,
    itemTransition,
    notFoundTransition
  )  
)</code></pre>
<p>
  I'll play a little bit more. Most routers have the ability to wrap a group of
  transitions with some prefix.
</p>
<pre><code class="hljs language-js">type PrefixTransition = <span class="hljs-function">(<span class="hljs-params">prefix: Url, transition: Transition</span>) =></span> Transition

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefixTransition</span>(<span class="hljs-params">prefix: Url, transition: Transition</span>): <span class="hljs-title">Transition</span> </span>{
  <span class="hljs-keyword">const</span> prefixRe: <span class="hljs-built_in">RegExp</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">${prefix}</span>`</span>)

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prefixedTransition</span>(<span class="hljs-params">url: Url</span>): <span class="hljs-title">Promise</span>&#x3C;?<span class="hljs-title">Screen</span>> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> transition(url.replace(prefixRe, <span class="hljs-string">''</span>))
  }
}

<span class="hljs-keyword">const</span> allTransitions = createErrorTransition(
  combineTransitions(
    prefixTransition(
      <span class="hljs-string">'/pages'</span>,
      combineTransitions(
        indexTransition,
        itemTransition
      )
    ),
    notFoundTransition
  )  
)</code></pre>
<p>
  To make this possible I've used higher-order functions. I've just wrapped the
  function to change its behavior, but I left the same interface. That allows me
  to create a both simple and powerful library API.
</p>
<p>
  In the next parts I'll implement support of the History API, tell you how to use
  the router on the server side, add redirect support, show you how to easily test
  all of this, and so on.
</p>
 ]]></description>
    <pubDate>Mon, 27 Jul 2015 00:00:00 GMT</pubDate>
  </item>
  
</channel>
</rss>
