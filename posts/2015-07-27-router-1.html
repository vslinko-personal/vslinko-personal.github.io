<!doctype html><html class=page itemscope itemtype=https://schema.org/BlogPosting lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Isomorphic router in functional paradigm — Blog — Viacheslav Slinko's website</title><link href=/css/normalize.css rel=stylesheet><link href=/css/screen.css rel=stylesheet><meta content="In this article I'll try to describe and implement a simple isomorphic router using functional paradigm principles." name=description><body class=page__body><article class=article><h1 class=article__header itemprop=headline>Isomorphic router in functional paradigm</h1><section class=article__content itemprop=articleBody><link href=/css/a11y-dark.min.css rel=stylesheet media="(prefers-color-scheme: dark)"><link href=/css/a11y-light.min.css rel=stylesheet media="(prefers-color-scheme: light)"><p>Recently, the functional paradigm has become more popular in the frontend community and elsewhere. I think it's wonderful because functions are much easier to write and test, this gives us more maintainable codebase, and we all know that maintenance is a pain. I won't describe the functional paradigm in depth, but I'll use its principles.. If you want to read about functional programming then you could read the article, <a href=http://www.defmacro.org/ramblings/fp.html rel=noopener>Functional Programming For The Rest of Us</a> and watch the slides, <a href=http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/ rel=noopener>Functional Programming</a>.<p>In addition to functional paradigm, the frontend community is developing ideas about isomorphic code and isomorphic applications. In short, isomorphic code runs on both sides, client and server. The pros are obvious — you can use the same code on both platforms and not repeat yourself.<p>To describe the meaning of isomorphic applications I should tell you about the main problem of modern client-side web applications. These days everyone owns some type of mobile device but the cellular network isn't good enough, which makes developers think about performance and interactivity. Loading time can be optimized on classic websites but they are not interactive enough. The opposite is true of web applications, which are much more interactive but have a long initialization process.<p>These problems are solved in isomorphic applications. Using isomorphic code, the server could initialize an instance of the client application for every request. This means that the server can send a pre-rendered application screen to the client and the client could show it to the user while other resources are still loading. After all resources have been loaded by the client, it could initialize its own instance of the application and replace the screen without the user knowing.<p>In this article series I'll try to describe and implement a simple isomorphic router using functional paradigm principles. My experience as a functional API architect isn't extensive, so I consider this an experiment.<p>I choose router because it's an important and integral part of any modern client-side web application. Most popular frameworks provide their own routers out of the box, but these routers usually aren't simple. I'll try to implement a simple and extendible router at the same time.<p>I'll use the awesome static type checker, <a href=http://flowtype.org/ rel=noopener>Flow</a>, and all of the new ECMAScript features available in <a href=https://babeljs.io/ rel=noopener>Babel</a>.<h2>Part 1 — Definitions</h2><p>Before implementation I should define what the router does and the individual router parts. It's really simple — the router transforms some URL into an action which changes the current screen of application. This action is usually called a <em>transition</em>. A transition could be asynchronous if the new screen depends on some data on a server. At the same time, a transition can't return a new screen if the URL isn't valid for it.<pre class=hljs><code class=lang-js><span class=hljs-keyword>type</span> <span class=hljs-type>Transition</span> = (url: <span class=hljs-type>Url</span>) => <span class=hljs-type>Promise</span>&lt;?<span class=hljs-type>Screen</span>>
</code></pre><p>The URL is just a string, but what is a screen? I don't want to depend on any framework or template engine so in my case, a screen could be any object.<pre class=hljs><code class=lang-js><span class=hljs-keyword>type</span> <span class=hljs-type>Url </span>= string
<span class=hljs-keyword>type</span> <span class=hljs-type>Screen </span>= Object
</code></pre><p>The router itself is a system that can push notifications about screen changes and can be notified about URL changes. It's very similar to <em>Observable</em> behavior that is implemented in the <a href=https://github.com/Reactive-Extensions/RxJS rel=noopener>RxJS</a> library, but I don't want complicate my router, so I just define a simple subscribe API.<pre class=hljs><code class=lang-js><span class=hljs-keyword>type</span> <span class=hljs-type>Listener</span>&lt;<span class=hljs-type>T</span>> = (value: ?<span class=hljs-type>T</span>) => void
<span class=hljs-keyword>type</span> <span class=hljs-type>Subscriber</span>&lt;<span class=hljs-type>T</span>> = (listener: <span class=hljs-type>Listener</span>&lt;<span class=hljs-type>T</span>>) => <span class=hljs-type>Unsubscriber</span>
<span class=hljs-keyword>type</span> <span class=hljs-type>Unsubscriber</span> = () => void

<span class=hljs-keyword>type</span> <span class=hljs-type>Router</span> = {
  subscribe: <span class=hljs-type>Subscriber</span>&lt;<span class=hljs-type>Screen</span>>,
  navigateTo: (url: <span class=hljs-type>Url</span>) => <span class=hljs-type>Promise</span>&lt;?<span class=hljs-type>Screen</span>>
}
</code></pre><p>Listener is a function that receives changes, Subscriber is a function that receives a listener and returns the Unsubscriber function. So Router has a function that subscribes on the current screen and a function that notifies the router about the current URL.<p>Isomorphism imposes a limitation on singletones usage. Also the router should have knowledge about all application transitions. The router constructor solves that problems.<pre class=hljs><code class=lang-js><span class=hljs-keyword>type</span> <span class=hljs-type>RouterCreator</span> = (transition: <span class=hljs-type>Transition</span>) => <span class=hljs-type>Router</span>
</code></pre><p>You could see that this constructor receives only one transition function. But every single application that needs the router has at least two transitions!<p>I could do it like in most big routers — write a standard for route definitions, accept array of routes, implement a matching algorithm, or I could provide to a user a lot of abstract classes like Route, RouteCollection, RouteMatchingStrategy, etc. All these variants make code and API more complicated and gives less freedom to configuration. My goal is the opposite - I want to make it all as simple as possible and functional paradigm helps me do that.<blockquote><p>Providing a single function into the router releases it from the requirement to implement different algorithms. For the router, that function is a fully prepared constructor of a screen.</blockquote><p>Transition is a simple function that's why we can apply to it every functional pattern, including higher-order functions. Using higher-order function, I can compose all application transitions into a single function. I'll describe this pattern in the next part.<p>That's all for basic router parts. Other definitions will be added later.<h2>Part 2. Higher-order transitions</h2><p>This part will contain more code than words. I'll start with two transition functions for two screens.<pre class=hljs><code class=lang-js>type QueryParameters = {[<span class=hljs-attribute>key</span>: <span class=hljs-built_in>string</span>]: <span class=hljs-built_in>string</span>}

<span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>indexTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
  <span class=hljs-keyword>if</span> (<span class=hljs-built_in>url</span> !== <span class=hljs-string>'/'</span>) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-keyword>const</span> props = <span class=hljs-keyword>await</span> api.fetchIndexData()

  <span class=hljs-keyword>return</span> {<span class=hljs-attribute>component</span>: <span class=hljs-string>'IndexPage'</span>, props}
}

<span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>itemTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
  <span class=hljs-keyword>const</span> <span class=hljs-attribute>queryParameters</span>: ?QueryParameters = matchRoutePattern(<span class=hljs-string>'/items/:id'</span>, <span class=hljs-built_in>url</span>)

  <span class=hljs-keyword>if</span> (!queryParameters) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-title>const</span> {id} = queryParameters

  <span class=hljs-keyword>const</span> props = <span class=hljs-keyword>await</span> api.fetchItemData({id})

  <span class=hljs-keyword>return</span> {<span class=hljs-attribute>component</span>: <span class=hljs-string>'ItemPage'</span>, props}
}
</code></pre><p>Pretty easy but I don't want to implement the URL matching in every transition. I've already extracted everything that I could into separate functions, but I can dig deeper. Functions in JavaScript are first-class citizens. This means that I can pass any function as an argument and return one function from another. Using these properties of JavaScript, I can write another function that will create transitions for me.<pre class=hljs><code class=lang-js>type TransitionHandler = <span class=hljs-function>(<span class=hljs-params>queryParameters: QueryParameters</span>) =></span> <span class=hljs-built_in>Promise</span>&lt;Screen>

type TransitionCreator = <span class=hljs-function>(<span class=hljs-params>pattern: string, handler: TransitionHandler</span>) =></span> Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createTransition</span>(<span class=hljs-params>pattern: string, handler: TransitionHandler</span>): <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>transition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>const</span> queryParameters: ?QueryParameters = matchRoutePattern(pattern, url)

    <span class=hljs-keyword>if</span> (queryParameters) {
      <span class=hljs-keyword>return</span> <span class=hljs-keyword>await</span> handler(queryParameters)
    }
  }
}
</code></pre><p>Now the transitions have become simpler.<pre class=hljs><code class=lang-js><span class=hljs-keyword>const</span> indexTransition: Transition = createTransition(<span class=hljs-string>'/'</span>,
  <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>queryParameters: QueryParameters</span>): <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>return</span> {
      <span class=hljs-attr>component</span>: <span class=hljs-string>'IndexPage'</span>,
      <span class=hljs-attr>props</span>: <span class=hljs-keyword>await</span> api.fetchIndexData()
    }
  }
)

<span class=hljs-keyword>const</span> itemTransition: Transition = createTransition(<span class=hljs-string>'/items/:id'</span>,
  <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>{id: string}: QueryParameters</span>): <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>return</span> {
      <span class=hljs-attr>component</span>: <span class=hljs-string>'ItemPage'</span>,
      <span class=hljs-attr>props</span>: <span class=hljs-keyword>await</span> api.fetchItemData({id})
    }
  }
)
</code></pre><p>However, how can I pass these two functions into one argument? To do this I'll create one more function that will combine several transitions into a single transition that will in turn invoke them in series.<pre class=hljs><code class=lang-js>type TransitionsCombinator = <span class=hljs-function>(<span class=hljs-params>...transitions: <span class=hljs-built_in>Array</span>&lt;Transition></span>) =></span> Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combineTransitions</span>(<span class=hljs-params>...transitions: Array&lt;Transition></span>): <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combinedTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>const</span> screens: <span class=hljs-built_in>Array</span>&lt;?Screen> =
      <span class=hljs-keyword>await</span>* transitions.map(<span class=hljs-function><span class=hljs-params>transition</span> =></span> transition(url))

    <span class=hljs-keyword>return</span> screens.find(<span class=hljs-function><span class=hljs-params>screen</span> =></span> screen !== <span class=hljs-literal>undefined</span>)
  }
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition
)
</code></pre><p>That's how most routers works. Implementing URL matching and data fetching in one function gives much more freedom to configuration and does't complicate the API.<p>I'll add one more transition for the screen of the 404 page.<pre class=hljs><code class=lang-js><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>notFoundTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
  <span class=hljs-keyword>return</span> {<span class=hljs-attr>component</span>: <span class=hljs-string>'NotFoundPage'</span>, <span class=hljs-attr>props</span>: {}}
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition,
  notFoundTransition
)
</code></pre><p>In the same way I can wrap all transitions so as to catch an error that I can use in the screen of the error page.<pre class=hljs><code class=lang-js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createErrorTransition</span>(<span class=hljs-params>transition: Transition</span>): <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>errorTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>try</span> {
      <span class=hljs-keyword>return</span> <span class=hljs-keyword>await</span> transition(url)
    } <span class=hljs-keyword>catch</span> (error) {
      <span class=hljs-keyword>return</span> {
        <span class=hljs-attr>component</span>: <span class=hljs-string>'ErrorPage'</span>,
        <span class=hljs-attr>props</span>: {error}
      }
    }
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    indexTransition,
    itemTransition,
    notFoundTransition
  )  
)
</code></pre><p>I'll play a little bit more. Most routers have the ability to wrap a group of transitions with some prefix.<pre class=hljs><code class=lang-js>type PrefixTransition = <span class=hljs-function>(<span class=hljs-params>prefix: Url, transition: Transition</span>) =></span> Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixTransition</span>(<span class=hljs-params>prefix: Url, transition: Transition</span>): <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>const</span> prefixRe: <span class=hljs-built_in>RegExp</span> = <span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(<span class=hljs-string>`^<span class=hljs-subst>${prefix}</span>`</span>)

  <span class=hljs-keyword>return</span> <span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixedTransition</span>(<span class=hljs-params>url: Url</span>): <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>> </span>{
    <span class=hljs-keyword>return</span> <span class=hljs-keyword>await</span> transition(url.replace(prefixRe, <span class=hljs-string>''</span>))
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    prefixTransition(
      <span class=hljs-string>'/pages'</span>,
      combineTransitions(
        indexTransition,
        itemTransition
      )
    ),
    notFoundTransition
  )  
)
</code></pre><p>To make this possible I've used higher-order functions. I've just wrapped the function to change its behavior, but I left the same interface. That allows me to create a both simple and powerful library API.<p>In the next parts I'll implement support of the History API, tell you how to use the router on the server side, add redirect support, show you how to easily test all of this, and so on.</section><footer class=article__footer><time datetime=2015-07-27 itemprop=datePublished>Jun 27th, 2015</time><br><a href=/ class=article__author itemprop=author itemscope itemtype=https://schema.org/Person><span itemprop=name>Viacheslav Slinko</span></a></footer></article><iframe class=comments_iframe src="/comments-iframe.html?page-id=https://vslinko.com/en/posts/2015-07-27-router-1.html"></iframe><footer class=footer><ul class=contacts><li class=contacts__item><a href=/ class=contacts__link>Home</a><li class=contacts__item><a href=/posts/ class=contacts__link>Blog</a><li class=contacts__item><a href=/garden/ class=contacts__link>Garden</a><li class=contacts__item><a href=https://t.me/vslinko class="contacts__link u-url" rel=noopener target=blank>Telegram</a><li class=contacts__item><a href=http://facebook.com/vslinko class="contacts__link u-url" rel=noopener target=blank>Facebook</a><li class=contacts__item><a href=https://ru.linkedin.com/in/vyacheslavslinko class="contacts__link u-url" rel=noopener target=blank>LinkedIn</a><li class=contacts__item><a href=https://github.com/vslinko class="contacts__link u-url" rel=noopener target=blank>Github</a><li class=contacts__item><a href=https://twitter.com/vslinko class="contacts__link u-url" rel=noopener target=blank>Twitter</a><li class=contacts__item><a href=mailto:me@vslinko.com class="contacts__link u-email">Email</a></ul></footer><script type=text/javascript>(function (m, e, t, r, i, k, a) {
    m[i] =
      m[i] ||
      function () {
        (m[i].a = m[i].a || []).push(arguments);
      };
    m[i].l = 1 * new Date();
    (k = e.createElement(t)),
      (a = e.getElementsByTagName(t)[0]),
      (k.async = 1),
      (k.src = r),
      a.parentNode.insertBefore(k, a);
  })(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(75142495, "init", {
    clickmap: true,
    trackLinks: true,
    accurateTrackBounce: true,
  });</script><noscript><div><img alt="" src=https://mc.yandex.ru/watch/75142495 style="position: absolute; left: -9999px"></div></noscript>