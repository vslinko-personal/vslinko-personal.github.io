<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><title>Vyacheslav Slinko's website — Isomorphic router in functional paradigm</title><link rel=stylesheet href="//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.2/normalize.min.css"><link rel=stylesheet href="//fonts.googleapis.com/css?family=Playfair+Display:400,700|PT+Sans:400,400italic,700|Inconsolata:400,700&amp;subset=latin,cyrillic"><link rel=stylesheet href="/css/screen.css"></head><body class=PostPage><div class=Header><a href="/" class=Header-Name>Vyacheslav Slinko</a><ul class=Header-Menu><li class=Header-Menu-Item><a class=Header-Link href=/resume.html>Resume</a></li><li class=Header-Menu-Item><a class=Header-Link href="/posts/">Blog</a></li></ul></div><div class=Post><div class=Post-Header><h1 class=Post-Title>Isomorphic router in functional paradigm</h1><span class=Post-Date>27 June 2015</span></div><div class=Post-Content><p>Recently, the functional paradigm become more popular in the frontend community (and not only that). I think it&#39;s wonderful because functions are much easier to write and test, this gives us more maintainable codebase, and we all know that maintenance is a pain. I won&#39;t to go far to describe the functional paradigm but I&#39;ll use its principles. If you want to read about functional programming then you could read the article, <a href=http://www.defmacro.org/ramblings/fp.html>Functional Programming For The Rest of Us</a> and watch the slides, <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/">Functional Programming</a>.</p><p>In addition to functional paradigm, the frontend community is developing ideas about isomorphic code and isomorphic applications. In short, isomorphic code runs on both sides, client and server. The pros are obvious — you can use the same code on both platforms and not repeat yourself.</p><p>To describe the meaning of isomorphic applications I should tell you about the main problem of modern client-side web applications. These days everyone owns some type of mobile device but the cellular network isn&#39;t good enough, which makes developers think about performance and interactivity. Loading time can be optimized on classic websites but they are not interactive enough. The opposite is true of web applications, which are much more interactive but have a long initialization process.</p><p>These problems are solved in isomorphic applications. Using isomorphic code, the server could initialize an instance of the client application for every request. This means that the server can send a pre-rendered application screen to the client and the client could show it to the user while other resources are still loading. After all resources have been loaded by the client, it could initialize its own instance of the application and replace the screen without the user knowing.</p><p>In this article series I&#39;ll try to describe and implement a simple isomorphic router using functional paradigm principles. My experience as a functional <abbr>API</abbr> architect isn&#39;t extensive, so I consider this an experiment.</p><p>I choose router because it&#39;s an important and integral part of any modern client-side web application. Most popular frameworks provide their own routers out of the box, but these routers usually aren&#39;t simple. I&#39;ll try to implement a simple and extendible router at the same time.</p><p>I&#39;ll use the awesome static type checker, <a href="http://flowtype.org/">Flow</a>, and all of the new <abbr>ECMAS</abbr>cript features available in <a href="https://babeljs.io/">Babel</a>.</p><hr><h2 id=part-1-definitions>Part 1 — Definitions</h2><p>Before implementation I should define what the router does and the individual router parts. It&#39;s really simple — the router transforms some <abbr>URL</abbr> into an action which changes the current screen of application. This action is usually called a <em>transition</em>. A transition could be asynchronous if the new screen depends on some data on a server. At the same time, a transition can&#39;t return a new screen if the <abbr>URL</abbr> isn&#39;t valid for it.</p><pre><code class="hljs js">type Transition = (url: Url) =&gt; Promise&lt;?Screen&gt;</code></pre><p>The <abbr>URL</abbr> is just a string, but what is a screen? I don&#39;t want to depend on any framework or template engine so in my case, a screen could be any object.</p><pre><code class="hljs js">type Url = string
type Screen = <span class=hljs-built_in>Object</span></code></pre><p>The router itself is a system that can push notifications about screen changes and can be notified about <abbr>URL</abbr> changes. It&#39;s very similar to <em>Observable</em> behavior that is implemented in the <a href=https://github.com/Reactive-Extensions/RxJS>RxJS</a> library, but I don&#39;t want complicate my router, so I just define a simple subscribe <abbr>API</abbr>.</p><pre><code class="hljs js">type Listener&lt;T&gt; = (value: ?T) =&gt; <span class=hljs-keyword>void</span>
type Subscriber&lt;T&gt; = (listener: Listener&lt;T&gt;) =&gt; Unsubscriber
type Unsubscriber = () =&gt; <span class=hljs-keyword>void</span>

type Router = {
  subscribe: Subscriber&lt;Screen&gt;,
  navigateTo: (url: Url) =&gt; Promise&lt;?Screen&gt;
}</code></pre><p>Listener is a function that receives changes, Subscriber is a function that receives a listener and returns the Unsubscriber function. So Router has a function that subscribes on the current screen and a function that notifies the router about the current <abbr>URL</abbr>.</p><p>Isomorphism imposes a limitation on singletones usage. Also the router should have knowledge about all application transitions. The router constructor solves that problems.</p><pre><code class="hljs js">type RouterCreator = (transition: Transition) =&gt; Router</code></pre><p>You could see that this constructor receives only one transition function. But every single application that needs the router has at least two transitions!</p><p>I could do it like in most big routers — write a standard for route definitions, accept array of routes, implement a matching algorithm, or I could provide to a user a lot of abstract classes like Route, RouteCollection, RouteMatchingStrategy, etc. All these variants make code and <abbr>API</abbr> more complicated and gives less freedom to configuration. My goal is the opposite - I want to make it all as simple as possible and functional paradigm helps me do that.</p><blockquote><p>Providing a single function into the router releases it from the requirement to implement different algorithms. For the router, that function is a fully prepared constructor of a screen.</p></blockquote><p>Transition is a simple function that&#39;s why we can apply to it every functional pattern, including higher-order functions. Using higher-order function, I can compose all application transitions into a single function. I&#39;ll describe this pattern in the next part.</p><p>That&#39;s all for basic router parts. Other definitions will be added later.</p><hr><h2 id=part-2-higher-order-transitions>Part 2. Higher-order transitions</h2><p>This part will contain more code than words. I&#39;ll start with two transition functions for two screens.</p><pre><code class="hljs js">type QueryParameters = {[key: string]: string}

async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>indexTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>if</span> (url !== <span class=hljs-string>'/'</span>) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-keyword>const</span> props = await api.fetchIndexData()

  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'IndexPage'</span>, props}
}

async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>itemTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>const</span> queryParameters: ?QueryParameters = matchRoutePattern(<span class=hljs-string>'/items/:id'</span>, url)

  <span class=hljs-keyword>if</span> (!queryParameters) {
    <span class=hljs-keyword>return</span>
  }

  <span class=hljs-keyword>const</span> {id} = queryParameters

  <span class=hljs-keyword>const</span> props = await api.fetchItemData({id})

  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'ItemPage'</span>, props}
}</code></pre><p>Pretty easy but I don&#39;t want to implement the <abbr>URL</abbr> matching in every transition. I&#39;ve already extracted everything that I could into separate functions, but I can dig deeper. Functions in JavaScript are first-class citizens. This means that I can pass any function as an argument and return one function from another. Using these properties of JavaScript, I can write another function that will create transitions for me.</p><pre><code class="hljs js">type TransitionHandler = (queryParameters: QueryParameters) =&gt; Promise&lt;Screen&gt;

type TransitionCreator = (pattern: string, handler: TransitionHandler) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createTransition</span><span class=hljs-params>(pattern: string, handler: TransitionHandler)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>transition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>const</span> queryParameters: ?QueryParameters = matchRoutePattern(pattern, url)

    <span class=hljs-keyword>if</span> (queryParameters) {
      <span class=hljs-keyword>return</span> await handler(queryParameters)
    }
  }
}</code></pre><p>Now the transitions have become simpler.</p><pre><code class="hljs js"><span class=hljs-keyword>const</span> indexTransition: Transition = createTransition(<span class=hljs-string>'/'</span>,
  async <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>(queryParameters: QueryParameters)</span>: <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> {
      component: <span class=hljs-string>'IndexPage'</span>,
      props: await api.fetchIndexData()
    }
  }
)

<span class=hljs-keyword>const</span> itemTransition: Transition = createTransition(<span class=hljs-string>'/items/:id'</span>,
  async <span class=hljs-function><span class=hljs-keyword>function</span><span class=hljs-params>({id: string}: QueryParameters)</span>: <span class=hljs-title>Promise</span>&lt;<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> {
      component: <span class=hljs-string>'ItemPage'</span>,
      props: await api.fetchItemData({id})
    }
  }
)</code></pre><p>However, how can I pass these two functions into one argument? To do this I&#39;ll create one more function that will combine several transitions into a single transition that will in turn invoke them in series.</p><pre><code class="hljs js">type TransitionsCombinator = (...transitions: <span class=hljs-built_in>Array</span>&lt;Transition&gt;) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combineTransitions</span><span class=hljs-params>(...transitions: Array&lt;Transition&gt;)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>combinedTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>const</span> screens: <span class=hljs-built_in>Array</span>&lt;?Screen&gt; =
      await* transitions.map(transition =&gt; transition(url))

    <span class=hljs-keyword>return</span> screens.find(screen =&gt; screen !== <span class=hljs-literal>undefined</span>)
  }
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition
)</code></pre><p>That&#39;s how most routers works. Implementing <abbr>URL</abbr> matching and data fetching in one function gives much more freedom to configuration and does&#39;t complicate the <abbr>API</abbr>.</p><p>I&#39;ll add one more transition for the screen of the 404 page.</p><pre><code class="hljs js">async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>notFoundTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
  <span class=hljs-keyword>return</span> {component: <span class=hljs-string>'NotFoundPage'</span>, props: {}}
}

<span class=hljs-keyword>const</span> allTransitions = combineTransitions(
  indexTransition,
  itemTransition,
  notFoundTransition
)</code></pre><p>In the same way I can wrap all transitions so as to catch an error that I can use in the screen of the error page.</p><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createErrorTransition</span><span class=hljs-params>(transition: Transition)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>errorTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>try</span> {
      <span class=hljs-keyword>return</span> await transition(url)
    } <span class=hljs-keyword>catch</span> (error) {
      <span class=hljs-keyword>return</span> {
        component: <span class=hljs-string>'ErrorPage'</span>,
        props: {error}
      }
    }
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    indexTransition,
    itemTransition,
    notFoundTransition
  )  
)</code></pre><p>I&#39;ll play a little bit more. Most routers have the ability to wrap a group of transitions with some prefix.</p><pre><code class="hljs js">type PrefixTransition = (prefix: Url, transition: Transition) =&gt; Transition

<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixTransition</span><span class=hljs-params>(prefix: Url, transition: Transition)</span>: <span class=hljs-title>Transition</span> </span>{
  <span class=hljs-keyword>const</span> prefixRe: <span class=hljs-built_in>RegExp</span> = <span class=hljs-keyword>new</span> <span class=hljs-built_in>RegExp</span>(`^${prefix}`)

  <span class=hljs-keyword>return</span> async <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>prefixedTransition</span><span class=hljs-params>(url: Url)</span>: <span class=hljs-title>Promise</span>&lt;?<span class=hljs-title>Screen</span>&gt; </span>{
    <span class=hljs-keyword>return</span> await transition(url.replace(prefixRe, <span class=hljs-string>''</span>))
  }
}

<span class=hljs-keyword>const</span> allTransitions = createErrorTransition(
  combineTransitions(
    prefixTransition(
      <span class=hljs-string>'/pages'</span>,
      combineTransitions(
        indexTransition,
        itemTransition
      )
    ),
    notFoundTransition
  )  
)</code></pre><p>To make this possible I&#39;ve used higher-order functions. I&#39;ve just wrapped the function to change its behavior, but I left the same interface. That allows me to create a both simple and powerful library <abbr>API</abbr>.</p><p>In the next parts I&#39;ll implement support of the History <abbr>API</abbr>, tell you how to use the router on the server side, add redirect support, show you how to easily test all of this, and so on.</p><hr><p class=Post-Note>Follow me on Twitter <a href=https://twitter.com/vslinko target=blank>@vslinko</a>.</p><hr><div id=disqus_thread></div></div></div><script>!function(){var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src="//vslinko-com.disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}();</script><link rel=stylesheet href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-58596861-1', 'auto');ga('send', 'pageview');</script></body></html>